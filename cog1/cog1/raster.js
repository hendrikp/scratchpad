/**
 * Rasterization algorithms.
 *
 * @namespace cog1
 * @module raster
 */
define(["exports", "dojo", "shader", "framebuffer", "data", "glMatrix"], function(exports, dojo, shader, framebuffer, data) {

	// Drawing context for canvas.
	// As raster uses the framebuffer to access the canvas,
	// ctx is merely for debug.
	var ctx;

	// Plane equation of polygon.
	var A = 1;
	var B = 1;
	var C = 1;
	var D = 1;
	var AdivC;
	// Pre-calculate for speed-up.

	// For each polygon we store all points from all edges
	// generated by the Bresenham algorithm.
	// They are use for the scan-line fill algorithm.
	// After processing a polygon the data structures are reset.
	// One ArrayList for every scan-line.
	var scanlineIntersection = [];

	function init(_ctx, _bgColor) {
		ctx = _ctx;
		framebuffer.init(ctx, _bgColor);
	}

	/*
	 * Convienence function when start and end points are given as 3D-vectors.
	 */
	function drawLineBresenhamGivenStartEndPoint(ctx, startPoint, endPoint, color, storeIntersectionForScanlineFill) {

		// Convert parameters to integer values.
		var startX = Math.floor(startPoint[0]);
		var startY = Math.floor(startPoint[1]);
		var endX = Math.floor(endPoint[0]);
		var endY = Math.floor(endPoint[1]);

		drawLineBresenham(ctx, startX, startY, endX, endY, color, storeIntersectionForScanlineFill);
	}

	/*
	 * Draw lines with bresenham algorithm.
	 * Also store intersections of the current edge for scanline.
	 * @ Start and end points should be integer values.
	 * @ parameter storeIntersectionForScanlineFill: if false edges are only calculated
	 * @ to be filled with scanline but not drawn.
	 */
	function drawLineBresenham(ctx, startX, startY, endX, endY, color, storeIntersectionForScanlineFill) {

		if(!isFinite(startX) || !isFinite(endX)|| !isFinite(startY)|| !isFinite(endY))
			return;
		
		if(startX < 0|| endX < 0 || startY < 0|| endY < 0)
			return;
		
		if(startX > framebuffer.width|| endX > framebuffer.width || startY > framebuffer.height || endY > framebuffer.height)
			return;
		
		// Set default color black.
		if(color == undefined) {
			color = [0, 0, 0];
		}
		var rgba = color.rgbaShaded;

		// Variables for the loops.
		var x = startX;
		var y = startY;

		var dX = endX - startX;
		var dY = endY - startY;
		var dXSign = dX >= 0 ? 1 : -1;

		// speedup for scanline
		if(dY == 0)
		{
			framebuffer.setDirtyPoint(x, y);
			framebuffer.setFast(x, y, getZ(x,y), rgba);
			while(x != endX)
			{
				x += dXSign;
				framebuffer.setFast(x, y, getZ(x,y), rgba);
			}
			framebuffer.setDirtyPoint(endX, endY);
			return;
		}
		
		var e;
		var dYSign = dY >= 0 ? 1 : -1;
		var dXAbs = Math.abs(dX);
		var dYAbs = Math.abs(dY);

		// shortcuts for speedup.
		var dXAbs2 = 2 * dXAbs;
		var dYAbs2 = 2 * dYAbs;
		var dXdYdiff2 = 2 * (dXAbs - dYAbs);
		var dYdXdiff2 = 2 * (dYAbs - dXAbs);

		// BEGIN exercise Bresenham
		framebuffer.setDirtyPoint(x,y);
		framebuffer.setFast(x, y, getZ(x,y), rgba);
		
		storeIntersectionForScanlineFill = storeIntersectionForScanlineFill && dYAbs > 0; // no horizontal lines
		
		if ( dXAbs >= dYAbs )
		{
			e = dXAbs - dYAbs2;
			while(x != endX)
			{
				x += dXSign;
				
				if(e > 0)
				{
					e -= dYAbs2;
				} else {
					e += dXdYdiff2;
					y += dYSign;
					
					if(storeIntersectionForScanlineFill && y != endY)
						addIntersection(x, y);
				}

				framebuffer.setFast(x, y, getZ(x,y), rgba);
			}
		} else
		{
			e = dYAbs - dXAbs2;
			while(y != endY)
			{
				y += dYSign;
				
				if(e > 0)
				{
					e -= dXAbs2;
				} else {
					e += dYdXdiff2;
					x += dXSign;
				}
				
				framebuffer.setFast(x, y, getZ(x,y), rgba);
				
				if(storeIntersectionForScanlineFill && y != endY)
					addIntersection(x, y);
			}
		}
		
		framebuffer.setDirtyPoint(x,y);
		
		// Overwrite this function
		// not using drawLine().Thus comment out the next line.
		// drawLine(ctx, startX, startY, endX, endY, color);
		return;
	};

	/*
	 * Fill a polygone into the frambuffer
	 * @parametes fill or stroke outline
	 * @parametes ctx is given for debug
	 */
	function scanlineDrawPolygon(ctx, vertices, polygon, color, fill) {

		// To fill the polygon, we want at least a triangle to proceed.
		if(fill && polygon.length < 3) {
			return;
		}

		if(fill) {
			clearIntersections();
		}

		// Calculate the plane in which the polygon lies
		// to determine z-values of intermediate points.
		calcPlaneEquation(vertices, polygon);

		// Convert parameters to integer values.
		var startPoint = vertices[polygon[polygon.length-1]];
		var nextIndex = 0;
		var endPoint = vertices[polygon[nextIndex]];
		var currX = Math.floor(startPoint[0]);
		var currY = Math.floor(startPoint[1]);
		var nextX = Math.floor(endPoint[0]);
		var nextY = Math.floor(endPoint[1]);

		var derivative = calcDerivative(currY, nextY);
		
		// Calculate first derivative
		if(derivative == 0)
		{
			for(var v = polygon.length-1; v >= 0; --v)
			{
				// Convert parameters to integer values.
				startPoint = vertices[polygon[v]];
				// Connect edge to next or to first vertex to close the polygon.
				nextIndex = (v < polygon.length - 1) ? v + 1 : 0;
				endPoint = vertices[polygon[nextIndex]];
				currY = Math.floor(startPoint[1]);
				nextY = Math.floor(endPoint[1]);
				
				derivative = calcDerivative(currY, nextY);
				
				if(derivative != 0)
					break;
			}
		}
		
		var lastDerivative = derivative;
		
		//console.log("y" + currY + "derivative:"+derivative+" lastDerivative "+lastDerivative); //debug.
		
		// Loop over vertices/edges in polygon.
		for(var v = 0; v < polygon.length; v++) {
			// Convert parameters to integer values.
			startPoint = vertices[polygon[v]];
			// Connect edge to next or to first vertex to close the polygon.
			nextIndex = (v < polygon.length - 1) ? v + 1 : 0;
			endPoint = vertices[polygon[nextIndex]];
			currX = Math.floor(startPoint[0]);
			currY = Math.floor(startPoint[1]);
			nextX = Math.floor(endPoint[0]);
			nextY = Math.floor(endPoint[1]);

			drawLineBresenham(ctx, currX, currY, nextX, nextY, color, fill);
			
			if(!fill) {
				continue;
			}
			
			// BEGIN exercise Scanline

			// Calculate current and save last derivative.
			lastDerivative = derivative;
			derivative = calcDerivative(currY, nextY);
			//console.log("y" + currY + "derivative:"+derivative+" lastDerivative "+lastDerivative); //debug.
			
			// Add start point if edges are non monotonous.
			if(derivative != 0 && derivative != lastDerivative)
			{
				addIntersection(currX, currY);
			}
			
			// Add end point of non horizontal edges.
			if(currY != nextY)
			{
				addIntersection(nextX, nextY);
			}
			
			// If current derivative ==0 then keep the last one that was not 0 as last.
			if(derivative == 0)
			{
				derivative = lastDerivative;
			}
		}

		if(!fill)
		{
			return;
		}
		
		// Fill polygon line by line using the scan-line algorithm.
		// Loop over scan lines.
		var numsort = function(a,b){return a-b};
		for(var y = 0; y < ctx.height; y++)
		{
			if(dojo.isArray(scanlineIntersection[y]))
			{
				scanlineIntersection[y].sort(numsort);

				for(var ix = 0; ix < scanlineIntersection[y].length-1; ix+=2)
				{					
					drawLineBresenham(ctx, scanlineIntersection[y][ix], y, scanlineIntersection[y][ix+1], y, color, false);
				}
			}
		}
	}

	/*
	 * Calculate the derivative (only the sign) of a polygon edge.
	 * @ return +-1 or 0.
	 */
	function calcDerivative(currY, nextY) {
		// y axis from top to bottom.
		if(currY < nextY) {
			return -1;
		} else if(currY > nextY) {
			return +1;
		} else {
			return 0;
		}
	}

	/*
	 * Used for drawing lines with correct z-buffering.
	 * Invent a second direction n perpendicular to direction
	 * and create a fake plane.
	 */
	function calcPlaneEquationForStraightLine(point, direction) {
		var d = direction;
		var n = vec3.create();
		// Calculate n via a second direction.
		//var d1 = vec3.create();
		//vec3.set([d[2],d[1],d[0]],d1);
		//vec3.cross(d, d1, n);
		// Set directly some n perpendicular to d.
		vec3.set([d[1], -d[0], -d[2]], n);
		vec3.normalize(n);
		A = n[0];
		B = n[1];
		C = n[2];
		D = -vec3.dot(n, point);
		AdivC = 0;
	}

	function calcPlaneEquation(vertices, polygon) {

		// Normal vector and its length.
		var n = vec3.create();
		var nLength = data.calculateNormalForPolygon(vertices, polygon, n);

		if(nLength == 0) {
			return;
		}

		// BEGIN exercise z-Buffer:

		// Assign parameters for plane equation.

		// Project first vertex (could be any) on normal.
		// The result is the distance D of polygon plane to origin.

		//console.log("Plane: A="+format.format(A)+" B="+format.format(B)+" C="+format.format(C)+" D="+format.format(D)+
		//			"   nLength="+nLength+"    A/C="+A/C); // debug
		
		
		// END exercise z-Buffer
	}

	/*
	 * Call for new frame.
	 */
	function clearIntersections() {
		scanlineIntersection = [];
	}

	/*
	 * Add (edge-)points from bresenham to scanlines.
	 */
	function addIntersection(x, y) {

		// Do some hacked clipping.
		// point out of y-range are on no scanline and can be ignored.
		if(y < 0 || y >= ctx.height) {
			return;
		}
		// Slide point to the left or right of the canvas back onto the edge,
		// but not on the canvas. They are cut off by the framebuffer if this
		// leads to a mere artifact (vertical lines at the left or right edge).
		if(x < 0) {
			x = -1;
		}
		if(x >= ctx.width) {
			x = ctx.width;
		}

		// Check if this is the first point in this scanline.
		if(!dojo.isArray(scanlineIntersection[y])) {
			scanlineIntersection[y] = [];
		}
		scanlineIntersection[y].push(x);
	}

	/*
	 * Calculate the z-value for any point on
	 * the polygon currently processed.
	 */
	function getZ(x, y) {
		// We assume that the plane equation is up-to-date
		// with the current polygon.
		return -(A * x + B * y + D) / C;
	}

	/*
	 * For Debug
	 */
	function drawLine(ctx, startX, startY, endX, endY, color) {
		var colorname = Object.keys(color)[0];
		ctx.fillStyle = colorname;
		ctx.strokeStyle = colorname;
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		//ctx.closePath();
		ctx.stroke();
	}

	// Public API.
	exports.init = init;
	exports.drawLineBresenham = drawLineBresenham;
	exports.drawLineBresenhamGivenStartEndPoint = drawLineBresenhamGivenStartEndPoint;
	exports.calcPlaneEquationForStraightLine = calcPlaneEquationForStraightLine;
	exports.scanlineDrawPolygon = scanlineDrawPolygon;
	exports.clearIntersections = clearIntersections;
});
